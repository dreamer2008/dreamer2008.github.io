[{"categories":null,"content":" 优秀的面向对象设计众所周知，软件=程序+文档+数据。通常来说，在一个软件系统的生命周期中，软件维护的时间»软件原始开发的时间。注：维护包括bug修复、各种优化和添加新功能。 所以，个人认为，优秀设计的终极目标是提高软件的可维护性(Maintainability)。不考虑可维护性的设计都是耍流氓。 除了这个终极目标之外，还有可复用性，可扩展性（甚至还有健壮性、灵活性，可插拔性等等），这些目标虽然含义不完全相同，但都是为了可维护性服务的。而所有这一切的基础，就是可读性。离开可读性，其他目标要么无法完成，要么代价特别大。它们的关系如下。 需要指出的是，文档的可读性也非常重要。例如，有的API很多指标都不错，就是文档写得乱七八糟，导致使用非常不方便，这就得不偿失了。 ","date":"2017-02-19","objectID":"/zh-cn/design-principles/:1:0","series":null,"tags":null,"title":"面向对象的设计原则","uri":"/zh-cn/design-principles/#优秀的面向对象设计"},{"categories":null,"content":" 面向对象的三大特性封装、继承、多态是面向对象的三个基本特性。这是面向对象的语言为了提高可复用性和可维护性而具有的基本特性，也是OO语言相对于非OO语言的优势。 ","date":"2017-02-19","objectID":"/zh-cn/design-principles/:2:0","series":null,"tags":null,"title":"面向对象的设计原则","uri":"/zh-cn/design-principles/#面向对象的三大特性"},{"categories":null,"content":" 面向对象设计的基本原则提到面向对象设计(OOD)，很多人会想到设计模式，但真正能把具体的设计模式信手拈来的又有多少呢？另一方面，其实这些设计模式只是具体的招数，不是内功。真正的内功心法更加重要，有了它们，你学习招数将更加顺手，即使不会具体的设计模式也能将软件设计得比较优雅，甚至你还可以在它们的指导下自创一些招数出来，做到“无招胜有招”。 ","date":"2017-02-19","objectID":"/zh-cn/design-principles/:3:0","series":null,"tags":null,"title":"面向对象的设计原则","uri":"/zh-cn/design-principles/#面向对象设计的基本原则"},{"categories":null,"content":" SOLID原则[SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)最早是由俗称「Uncle Bob」的Robert C. Martin提出。他也是\"Clean Code\"这本书的作者。SOLID代表以下5大设计原则。 Single Responsibility Principle(SRP,单一职责原则): 一个类应该有且只有一个去改变它的理由，这意味着一个类应该只有一个职责 Open/Closed Principle(OCP,开闭原则): 对象或实体应该对扩展开放，对修改封闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类 Liskov Substitution Principle(LSP,里氏替换原则): 任何基类可以出现的地方，子类一定可以出现。在对象 x 为类型 T 时 q(x) 成立，那么当 S 是 T 的子类时，对象 y 为类型 S 时 q(y) 也应成立。（即对父类的调用同样适用于子类） Interface Segregation Principle(ISP,接口隔离原则): 使用多个隔离/客户端相关的接口，比使用单个通用接口要好 Dependency Inversion Principle(DIP,依赖反转原则): 实体必须依靠抽象而不是具体实现。它表示高层次的模块不应该依赖于低层次的模块，它们都应该依赖于抽象 ","date":"2017-02-19","objectID":"/zh-cn/design-principles/:3:1","series":null,"tags":null,"title":"面向对象的设计原则","uri":"/zh-cn/design-principles/#solid原则"},{"categories":null,"content":" 其他常用原则除了SOLID原则，还有一些其他原则会经常被提到。 Composite Reuse Principle(CRP,合成复用原则):尽量使用合成/聚合的方式，而不是使用继承 迪米特法则(Law of Demeter) 又叫最少知道原则(Least Knowledge Principle)。一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立 避免重复原则（DRY - Don’t Repeat Yourself） 又叫一次且仅一次（once and only once，简称OAOO)。编程的最基本原则是避免重复。在程序代码中总会有很多结构体，如循环、函数、类等等。一旦你重复某个语句或概念，就会很容易形成一个抽象体 简单原则（Keep It Simple and Stupid） 简单是软件设计的目标，简单的代码占用时间少，漏洞少，并且易于修改 避免过早优化(Avoid Premature Optimization) 除非你的代码运行的比你想像中的要慢，否则别去优化。假如你真的想优化，就必须先想好如何用数据证明，它的速度变快了。 “过早的优化是一切罪恶的根源”——Donald Knuth ","date":"2017-02-19","objectID":"/zh-cn/design-principles/:3:2","series":null,"tags":null,"title":"面向对象的设计原则","uri":"/zh-cn/design-principles/#其他常用原则"},{"categories":null,"content":" 面向对象","date":"2017-01-17","objectID":"/zh-cn/python-note3/:0:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记3","uri":"/zh-cn/python-note3/#面向对象"},{"categories":null,"content":" 基本概念Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。 对象可以包含任意数量和类型的数据。 OOP：属性(Property)和方法(Method)。 类（Class）和实例（Instance） class Student(object): def __init__(self, name, score): self.name = name self.score = score #!/usr/bin/python3 class MyClass: \"\"\"一个简单的类实例\"\"\" i = 12345 def f(self): return 'hello world' # 实例化类 x = MyClass() # 访问类的属性和方法 print(\"MyClass 类的属性 i 为：\", x.i) print(\"MyClass 类的方法 f 输出为：\", x.f()) ##访问控制 class Student(object): ... def get_name(self): return self.__name def get_score(self): return self.__score 需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。 有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。 ","date":"2017-01-17","objectID":"/zh-cn/python-note3/:1:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记3","uri":"/zh-cn/python-note3/#基本概念"},{"categories":null,"content":" 继承和多态动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子 ","date":"2017-01-17","objectID":"/zh-cn/python-note3/:2:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记3","uri":"/zh-cn/python-note3/#继承和多态"},{"categories":null,"content":" 获取对象信息###使用type() \u003e\u003e\u003e type(fn)==types.FunctionType True ###使用isinstance() ###使用dir() 类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法，所以，下面的代码是等价的： \u003e\u003e\u003e len('ABC') 3 \u003e\u003e\u003e 'ABC'.__len__() 3 仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态： \u003e\u003e\u003e class MyObject(object): ... def __init__(self): ... self.x = 9 ... def power(self): ... return self.x * self.x ... \u003e\u003e\u003e obj = MyObject() \u003e\u003e\u003e def readImage(fp): if hasattr(fp, 'read'): return readData(fp) return None ###实例属性和类属性 类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。self 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定是用 self ","date":"2017-01-17","objectID":"/zh-cn/python-note3/:3:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记3","uri":"/zh-cn/python-note3/#获取对象信息"},{"categories":null,"content":" 类的私有属性和私有方法","date":"2017-01-17","objectID":"/zh-cn/python-note3/:3:1","series":null,"tags":["开发","Python"],"title":"Python学习笔记3","uri":"/zh-cn/python-note3/#类的私有属性和私有方法"},{"categories":null,"content":" trouble shooting","date":"2017-01-17","objectID":"/zh-cn/python-note3/:0:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记3","uri":"/zh-cn/python-note3/#trouble-shooting"},{"categories":null,"content":" 异常捕获Python的错误其实也是class，所有的错误类型都继承自BaseException try: print('try...') r = 10 / int('2') print('result:', r) except ValueError as e: print('ValueError:', e) except ZeroDivisionError as e: print('ZeroDivisionError:', e) else: print('no error!') finally: print('finally...') print('END') ","date":"2017-01-17","objectID":"/zh-cn/python-note3/:1:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记3","uri":"/zh-cn/python-note3/#异常捕获"},{"categories":null,"content":" 用户自定义异常 \u003e\u003e\u003e class MyError(Exception): def __init__(self, value): self.value = value def __str__(self): return repr(self.value) ","date":"2017-01-17","objectID":"/zh-cn/python-note3/:1:1","series":null,"tags":["开发","Python"],"title":"Python学习笔记3","uri":"/zh-cn/python-note3/#用户自定义异常"},{"categories":null,"content":" 断言 assert n != 0, 'n is zero!' ","date":"2017-01-17","objectID":"/zh-cn/python-note3/:2:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记3","uri":"/zh-cn/python-note3/#断言"},{"categories":null,"content":" logging import logging logging.basicConfig(level=logging.INFO) ","date":"2017-01-17","objectID":"/zh-cn/python-note3/:3:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记3","uri":"/zh-cn/python-note3/#logging"},{"categories":null,"content":" pdbpdb.set_trace() # 运行到这里会自动暂停 ","date":"2017-01-17","objectID":"/zh-cn/python-note3/:4:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记3","uri":"/zh-cn/python-note3/#pdb"},{"categories":null,"content":" 参考资料","date":"2017-01-17","objectID":"/zh-cn/python-note3/:0:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记3","uri":"/zh-cn/python-note3/#参考资料"},{"categories":null,"content":" Python 2.x vs 3.x2008年, Python3发布。最大的变化是源码文件默认使用utf-8编码 更多区别：Python3.x和Python2.x的区别 ","date":"2017-01-17","objectID":"/zh-cn/python-note3/:1:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记3","uri":"/zh-cn/python-note3/#python-2x-vs-3x"},{"categories":null,"content":" 学习材料 廖雪峰Python3教程 Runoob Python3教程 PHPXS Python基础教程 ","date":"2017-01-17","objectID":"/zh-cn/python-note3/:2:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记3","uri":"/zh-cn/python-note3/#学习材料"},{"categories":null,"content":" 函数函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段 ","date":"2016-06-05","objectID":"/zh-cn/python-note2/:0:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记2","uri":"/zh-cn/python-note2/#函数"},{"categories":null,"content":" 参数传递 传不可变对象实例：在 python 中，strings, tuples, 和 numbers 是不可更改的对象 传可变对象实例：而 list,dict 等则是可以修改的对象 ","date":"2016-06-05","objectID":"/zh-cn/python-note2/:1:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记2","uri":"/zh-cn/python-note2/#参数传递"},{"categories":null,"content":" 参数类型 必需参数 关键字参数：使用关键字参数允许函数调用时参数的顺序与声明时不一致 默认参数 变长参数 ","date":"2016-06-05","objectID":"/zh-cn/python-note2/:2:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记2","uri":"/zh-cn/python-note2/#参数类型"},{"categories":null,"content":" 递归函数","date":"2016-06-05","objectID":"/zh-cn/python-note2/:3:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记2","uri":"/zh-cn/python-note2/#递归函数"},{"categories":null,"content":" 匿名函数lambda [arg1 [,arg2,…..argn]]:expression sum = lambda arg1, arg2: arg1 + arg2; # 调用sum函数 print (\"相加后的值为 : \", sum( 10, 20 )) print (\"相加后的值为 : \", sum( 20, 20 )) ","date":"2016-06-05","objectID":"/zh-cn/python-note2/:4:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记2","uri":"/zh-cn/python-note2/#匿名函数"},{"categories":null,"content":" 变量作用域变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4中，分别是： L （Local） 局部作用域 E （Enclosing） 闭包函数外的函数中 G （Global） 全局作用域 B （Built-in） 内建作用域 以 L –\u003e E –\u003e G –\u003eB 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。 Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这这些语句内定义的变量，外部也可以访问 ","date":"2016-06-05","objectID":"/zh-cn/python-note2/:5:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记2","uri":"/zh-cn/python-note2/#变量作用域"},{"categories":null,"content":" global 和 nonlocal关键字","date":"2016-06-05","objectID":"/zh-cn/python-note2/:5:1","series":null,"tags":["开发","Python"],"title":"Python学习笔记2","uri":"/zh-cn/python-note2/#global-和-nonlocal关键字"},{"categories":null,"content":" 高级特性","date":"2016-06-05","objectID":"/zh-cn/python-note2/:0:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记2","uri":"/zh-cn/python-note2/#高级特性"},{"categories":null,"content":" 切片list,tuple,string都适用。有了切片操作，很多地方循环就不再需要了 L = list(range(100)) L[:10] L[-10:] L[:10:2] (0, 1, 2, 3, 4, 5)[:3] 'ABCDEFG'[::2] ","date":"2016-06-05","objectID":"/zh-cn/python-note2/:1:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记2","uri":"/zh-cn/python-note2/#切片"},{"categories":null,"content":" 迭代任何可迭代对象都可以作用于for循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用for循环 for i, value in enumerate(['A', 'B', 'C']): for x, y in [(1, 1), (2, 4), (3, 9)]: ","date":"2016-06-05","objectID":"/zh-cn/python-note2/:2:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记2","uri":"/zh-cn/python-note2/#迭代"},{"categories":null,"content":" 列表生成式（List Comprehensions） \u003e\u003e\u003e list(range(1, 11)) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] [x * x for x in range(1, 11) if x % 2 == 0] [m + n for m in 'ABC' for n in 'XYZ'] ##生成器（generator） 第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator。 第二种：yield关键字 ##迭代器 凡是可作用于for循环的对象都是Iterable类型； 凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；迭代器有两个基本的方法：iter() 和 next() 集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象 # 首先获得Iterator对象: it = iter([1, 2, 3, 4, 5]) # 循环: while True: try: # 获得下一个值: x = next(it) except StopIteration: # 遇到StopIteration就退出循环 break ","date":"2016-06-05","objectID":"/zh-cn/python-note2/:3:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记2","uri":"/zh-cn/python-note2/#列表生成式list-comprehensions"},{"categories":null,"content":" 函数式编程函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！ Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言 ","date":"2016-06-05","objectID":"/zh-cn/python-note2/:0:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记2","uri":"/zh-cn/python-note2/#函数式编程"},{"categories":null,"content":" 高阶函数把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。 ###变量可以指向函数 ###函数名也是变量 ###传入函数 ","date":"2016-06-05","objectID":"/zh-cn/python-note2/:1:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记2","uri":"/zh-cn/python-note2/#高阶函数"},{"categories":null,"content":" map/reducemap()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回 def f(x): return x * x r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) list(r) [1, 4, 9, 16, 25, 36, 49, 64, 81] reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是： reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) ##filter 和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素 def is_odd(n): return n % 2 == 1 list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])) # 结果: [1, 5, 9, 15] ##sorted sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序： sorted([36, 5, -12, 9, -21], key=abs) [5, 9, -12, -21, 36] ##返回函数 一个函数可以返回一个计算结果，也可以返回一个函数。 返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量 ###函数作为返回值 def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum ###闭包 ","date":"2016-06-05","objectID":"/zh-cn/python-note2/:2:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记2","uri":"/zh-cn/python-note2/#mapreduce"},{"categories":null,"content":" 装饰器","date":"2016-06-05","objectID":"/zh-cn/python-note2/:3:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记2","uri":"/zh-cn/python-note2/#装饰器"},{"categories":null,"content":" 偏函数 \u003e\u003e\u003e import functools \u003e\u003e\u003e int2 = functools.partial(int, base=2) \u003e\u003e\u003e int2('1000000') 64 \u003e\u003e\u003e int2('1010101') 85 ","date":"2016-06-05","objectID":"/zh-cn/python-note2/:4:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记2","uri":"/zh-cn/python-note2/#偏函数"},{"categories":null,"content":" 模块一个.py文件就称之为一个模块（Module） 为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package） ##作用域 有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的 __name__属性 #!/usr/bin/python3 # Filename: using_name.py if __name__ == '__main__': print('程序自身在运行') else: print('我来自另一模块') #三方模块 ","date":"2016-06-05","objectID":"/zh-cn/python-note2/:0:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记2","uri":"/zh-cn/python-note2/#模块"},{"categories":null,"content":" 安装pip install Pillow ","date":"2016-06-05","objectID":"/zh-cn/python-note2/:1:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记2","uri":"/zh-cn/python-note2/#安装"},{"categories":null,"content":" 导入import x.y.z from x.y import z/* ","date":"2016-06-05","objectID":"/zh-cn/python-note2/:1:1","series":null,"tags":["开发","Python"],"title":"Python学习笔记2","uri":"/zh-cn/python-note2/#导入"},{"categories":null,"content":" 参考资料","date":"2016-06-05","objectID":"/zh-cn/python-note2/:0:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记2","uri":"/zh-cn/python-note2/#参考资料"},{"categories":null,"content":" Python 2.x vs 3.x2008年, Python3发布。最大的变化是源码文件默认使用utf-8编码 更多区别：Python3.x和Python2.x的区别 ","date":"2016-06-05","objectID":"/zh-cn/python-note2/:1:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记2","uri":"/zh-cn/python-note2/#python-2x-vs-3x"},{"categories":null,"content":" 学习材料 廖雪峰Python3教程 Runoob Python3教程 PHPXS Python基础教程 ","date":"2016-06-05","objectID":"/zh-cn/python-note2/:2:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记2","uri":"/zh-cn/python-note2/#学习材料"},{"categories":null,"content":" 引子正如译者所言。在软件的生命周期中，往往维护成本»开发成本。而维护成本又会随着软件复杂度的降低而降低，所有，我们要尽量降低软件的复杂度。 ","date":"2016-05-07","objectID":"/zh-cn/code-simplicity/:0:0","series":null,"tags":null,"title":"简约之美：软件设计之道","uri":"/zh-cn/code-simplicity/#引子"},{"categories":null,"content":" 内容简介 优秀的软件设计简单明了。不过很遗憾，如今的计算机程序基本上都很复杂，恐怕无人能够确切知道所有代码都是怎么运转的。这本简明《简约之美：软件设计之道》旨在帮助读者利用科学规则掌握优秀设计的基础知识，《简约之美：软件设计之道》中给出的法则适用于所有编程语言和软件项目，并且永远有效。 ","date":"2016-05-07","objectID":"/zh-cn/code-simplicity/:0:0","series":null,"tags":null,"title":"简约之美：软件设计之道","uri":"/zh-cn/code-simplicity/#内容简介"},{"categories":null,"content":" 笔记 好程序员和差程序员的区别在于理解能力。差劲的程序员不理解自己做的事情 我们学习提高代码质量的全部原因在于，要想改进结果，提高代码质量是最重要的问题 作者将软件设计视为一门科学。软件设计的科学就是为软件做计划、制定决策的科学，它帮助大家制定这类决定： 1）程序的代码应当采用什么结构？ 2）是程序的速度重要，还是程序代码容易阅读重要？ 3）为满足需求，应该选择哪种编程语言？ 软件系统中任何与架构有关的技术决策，以及在开发系统中所做的技术决策，都可以归到“软件设计”的范畴里。 每个写代码的人都是设计师 一个人写出优秀软件的潜力，完全取决于他在多大程度上理解了“帮助其他人”的思想。在做与软件设计有关的决策时，指导法则就是判断能提供什么样的帮助（帮大忙、帮小忙，帮很多人、帮少数人） 设计程序员能尽可能容易开发和维护的软件系统，这样的系统才能为用户提供尽可能多的帮助，而且能持续提供尽可能多的帮助。 软件设计的方程式：D = V / E 1）任何一点改变，其可取成都与其价值成正比，与所付出的成本成反比 2）价值：包括可能价值和潜在价值 3）成本：包括调研的时间+沟通的时间+思考的时间+编码的时间 完整的方程式： D = (Vn + Vf) / (Ei + Em) 1）Vn：当前价值 Vf：未来价值 Ei：实现成本 Em：维护成本 2）随着时间的发展，D -\u003e Vf / Em 3）相比降低实现成本，降低维护成本更重要。在软件设计科学中，这点非常重要 设计的质量好坏，正比于该系统在未来能持续帮助他人时间的长短 变化定律：程序存在的时间越久，它的某个部分需要变化的可能性就越高 软件设计的三大误区： 1）编写不必要的代码 不要编写非必需的代码，而且要删除没用的代码 2）代码难以修改 僵化设计（rigid design）有两大原因：对未来做太多假设，不仔细设计就编码。设计程序时，应当根据你现在确切知道的需求，而不是你认为未来会出现的需求 3）过分追求通用 避免以上三大误区：渐进设计和开发，小步快跑 缺陷概率定律：在程序中新增缺陷的可能性与代码修改量成正比 最好的设计，就是能适应外界尽可能多的变化，而软件自身的变化要尽可能少 永远不要“修复”任何东西，除非它真的是问题，而且有证据表明它的存在 理想情况下，任何系统里的任何信息，都应当只存在一次 简洁定律：软件任何一部分的维护难度，正比于该部分的简洁程度 简洁是相对的。简单到啥子都能看懂 保持可读性、一致性，简单的设计 除了新增功能，以下做法也会增加复杂性 1）扩展软件用途 2）新增程序员 3）做无谓的改变 4）困于糟糕的技术 5）理解错误 6）糟糕的设计或不做设计 7）重新发明轮子 复杂问题 1）大多数麻烦的设计问题，都可以用在纸上画图或写出来的办法找到答案 2）如果某个部分太复杂，就将其分解成小任务。。。分而治之 3）可以在做新功能的时间做重新设计和简化 推倒重来，需要同时满足以下条件 1）已经完成了准确评估，证明重写比重构好 2）有足够的时间 3）设计水平要比原来高 4）完全打算好了设计新系统，在每一步都有用户提供反馈 5）有足够的资源，可兼顾维护老系统和开发新系统 测试定律：你对软件行为的了解程度，等于你对它的测试程序 ","date":"2016-05-07","objectID":"/zh-cn/code-simplicity/:0:0","series":null,"tags":null,"title":"简约之美：软件设计之道","uri":"/zh-cn/code-simplicity/#笔记"},{"categories":null,"content":" 引子写代码是程序员的基本功。但是，程序员，你真的会写代码吗？今天，我们不谈什么高大上的“架构”，就谈谈怎么写代码。 作为程序员，你看过、写过、改过、删过的代码可能不计其数。然而，回头想想，真正让你感到赏心悦目、拍手称快的代码又有多少呢？要知道，你读代码的时间远远大于你实际写代码的时间。如果代码可读性不好，你的工作效率肯定会大打折扣。特别是，对于一个团队来说，如果没有良好的、统一的代码规范，协同工作效率必然很受影响，造成不必要的时间浪费。 《Clean Code》的作者Bob大叔认为“在代码阅读过程中人们说脏话的频率是衡量代码质量的唯一标准。” 哈哈。太TM经典了。 书的目录如下： （图片来源：xingoo的博客） ","date":"2016-03-06","objectID":"/zh-cn/readable-code/:0:0","series":null,"tags":null,"title":"编写可读代码的艺术","uri":"/zh-cn/readable-code/#引子"},{"categories":null,"content":" 内容简介 细节决定成败，思路清晰、言简意赅的代码让程序员一目了然；而格式凌乱、拖沓冗长的代码让程序员一头雾水。除了可以正确运行以外，优秀的代码必须具备良好的可读性，编写的代码要使其他人能在最短的时间内理解才行。本书旨在强调代码对人的友好性和可读性。 ","date":"2016-03-06","objectID":"/zh-cn/readable-code/:0:0","series":null,"tags":null,"title":"编写可读代码的艺术","uri":"/zh-cn/readable-code/#内容简介"},{"categories":null,"content":" 可读性为什么重要","date":"2016-03-06","objectID":"/zh-cn/readable-code/:0:0","series":null,"tags":null,"title":"编写可读代码的艺术","uri":"/zh-cn/readable-code/#可读性为什么重要"},{"categories":null,"content":" 书中观点 软件成本 = 开发成本 + 维护成本。往往，维护成本»开发成本。这其中耗费的主要成本就是由于理解代码和修改代码造成的。 ——《Structured Design》 ","date":"2016-03-06","objectID":"/zh-cn/readable-code/:1:0","series":null,"tags":null,"title":"编写可读代码的艺术","uri":"/zh-cn/readable-code/#书中观点"},{"categories":null,"content":" 个人观点 可读性永远是第一位的。代码的可读性与效率、架构、易于测试一点也不冲突。 代码可读性好、bug少是对程序员的基本要求。 ","date":"2016-03-06","objectID":"/zh-cn/readable-code/:2:0","series":null,"tags":null,"title":"编写可读代码的艺术","uri":"/zh-cn/readable-code/#个人观点"},{"categories":null,"content":" 前言 本书旨在帮助你把代码写得更好 。。。我们希望本书对你每天的编程工作有很多帮助，并且希望你把本书推荐给你团队中的每个人。 本文从命名、注释、代码布局、简化逻辑等方面阐述如何写出可读性高的代码 ","date":"2016-03-06","objectID":"/zh-cn/readable-code/:0:0","series":null,"tags":null,"title":"编写可读代码的艺术","uri":"/zh-cn/readable-code/#前言"},{"categories":null,"content":" 总结","date":"2016-03-06","objectID":"/zh-cn/readable-code/:0:0","series":null,"tags":null,"title":"编写可读代码的艺术","uri":"/zh-cn/readable-code/#总结"},{"categories":null,"content":" 第1章 代码应当易于理解 可读性基本定理 Code should be written to minimize the time it would take for someone else to understand it. 代码的写法应当使别人理解它所需的时间最小化。 ","date":"2016-03-06","objectID":"/zh-cn/readable-code/:1:0","series":null,"tags":null,"title":"编写可读代码的艺术","uri":"/zh-cn/readable-code/#第1章-代码应当易于理解"},{"categories":null,"content":" 第一部分 表面层次的改进 一定要让命名可以“自解释”，尽量具体形象。不要随便缩写，可读性比变量长短重要的多（当然也不要太长） 不要用汉语拼音，不要使用有二义性的词，如filter 注意代码的美观：缩进、分段、空格、空行、适当的对齐、顺序的一致性。在团队中，一致的风格比“正确”的风格重要。如，句尾的大括号 好代码\u003e坏代码+好注释。为缺陷加TODO注释。为特殊的地方写注释。写不同层次的注释。行级\u003c方法级\u003c文件级\u003c包级 使用明确、恰当、含义丰富的词精确描述函数的行为。注释中可以给出I/O的例子 ","date":"2016-03-06","objectID":"/zh-cn/readable-code/:2:0","series":null,"tags":null,"title":"编写可读代码的艺术","uri":"/zh-cn/readable-code/#第一部分-表面层次的改进"},{"categories":null,"content":" 第二部分 简化循环和逻辑 形式上嵌套一般不超过2层，能return的尽早return。这个原则可以让你大大降低if-else的嵌套深度 不要滥用三目运算符 一定要做参数校验。对于不合法的参数：直接return、抛出异常、logging 拆分过长或者过于复杂的表达式：解释变量、总结变量 减少不必要的变量、合理控制变量的作用域 ","date":"2016-03-06","objectID":"/zh-cn/readable-code/:3:0","series":null,"tags":null,"title":"编写可读代码的艺术","uri":"/zh-cn/readable-code/#第二部分-简化循环和逻辑"},{"categories":null,"content":" 第三部分 重新组织代码 抽出不相关的子问题，封装起来。如：各种工具类 将通用代码和项目专有代码分开 一次只做一件事情 用自然语言描述问题，理清思路，能写出更好懂的代码 质疑和拆分你的需求，消除不必要的功能 保持代码库的轻量级，删除无用代码，尽量使用库函数 ","date":"2016-03-06","objectID":"/zh-cn/readable-code/:4:0","series":null,"tags":null,"title":"编写可读代码的艺术","uri":"/zh-cn/readable-code/#第三部分-重新组织代码"},{"categories":null,"content":" 第四部分 精选话题 测试代码的可读性与非测试代码的可读性同样重要 对测试代码的使用者隐去不重要的细节，以便突出更重要的细节 让错误信息具有更好的可读性 又简单又能完成工作的测试值更好 为测试函数起个好的名字。Test_类名_方法名_情形 过犹不及： 1）牺牲生产代码的可读性，只是为了方便测试 2）顽固地追求100%的测试覆盖率 3）让测试成为产品开发的主导和障碍 ","date":"2016-03-06","objectID":"/zh-cn/readable-code/:5:0","series":null,"tags":null,"title":"编写可读代码的艺术","uri":"/zh-cn/readable-code/#第四部分-精选话题"},{"categories":null,"content":" 我对这些书感兴趣 科学技术（包括IT）方面的人、事、物 经济管理类和职业发展 欧美文化 数学、外语 历史、地理 传记与其他 ","date":"2016-01-23","objectID":"/zh-cn/reading/:1:0","series":null,"tags":null,"title":"我的书单","uri":"/zh-cn/reading/#我对这些书感兴趣"},{"categories":null,"content":" 2016年","date":"2016-01-23","objectID":"/zh-cn/reading/:2:0","series":null,"tags":null,"title":"我的书单","uri":"/zh-cn/reading/#2016年"},{"categories":null,"content":" 科学技术 编写可读代码的艺术 简约之美：软件设计之道 Web全栈工程师的自我修养 程序员必读之软件架构 恰如其分的软件架构 Effective Java中文版（第2版） 编写高质量代码：改善Java程序的151个建议 重构 改善既有代码的设计 代码整洁之道 ","date":"2016-01-23","objectID":"/zh-cn/reading/:2:1","series":null,"tags":null,"title":"我的书单","uri":"/zh-cn/reading/#科学技术"},{"categories":null,"content":" 经济管理 玩转电商系统 深入剖析智慧电商平台 成为技术领导者：掌握全面解决问题的方法 技术管理之巅：如何从零打造高质效互联网技术团队？ ","date":"2016-01-23","objectID":"/zh-cn/reading/:2:2","series":null,"tags":null,"title":"我的书单","uri":"/zh-cn/reading/#经济管理"},{"categories":null,"content":" 历史传记 搅局的人——匈奴入侵欧洲简史 ","date":"2016-01-23","objectID":"/zh-cn/reading/:2:3","series":null,"tags":null,"title":"我的书单","uri":"/zh-cn/reading/#历史传记"},{"categories":null,"content":" 其他 异类：不一样的成功启示录（新版） 一万小时天才理论 ","date":"2016-01-23","objectID":"/zh-cn/reading/:2:4","series":null,"tags":null,"title":"我的书单","uri":"/zh-cn/reading/#其他"},{"categories":null,"content":" 2015年 以色列人：特殊国土上的普通人 新加坡的那些事儿 我们台湾这些年：1977年至今 ","date":"2016-01-23","objectID":"/zh-cn/reading/:3:0","series":null,"tags":null,"title":"我的书单","uri":"/zh-cn/reading/#2015年"},{"categories":null,"content":" Python入门","date":"2016-01-17","objectID":"/zh-cn/python-note1/:0:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#python入门"},{"categories":null,"content":" Python简介脚本语言。解释语言。动态语言。默认的解释器CPython。 Python之父—荷兰人Guido van Rossum。诞生于1989年。第一个公开发行版发行于1991年 ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:1:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#python简介"},{"categories":null,"content":" Python用途 是网络应用，包括网站、后台服务等等； 其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等； 另外就是把其他语言开发的程序再包装起来，方便使用 目前广泛应用于大数据和人工智能领域 ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:2:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#python用途"},{"categories":null,"content":" Python优缺点 性能差 源码不能加密 ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:3:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#python优缺点"},{"categories":null,"content":" 第一个Python程序 print('hello,world') ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:4:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#第一个python程序"},{"categories":null,"content":" 编程方式","date":"2016-01-17","objectID":"/zh-cn/python-note1/:5:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#编程方式"},{"categories":null,"content":" 交互式","date":"2016-01-17","objectID":"/zh-cn/python-note1/:5:1","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#交互式"},{"categories":null,"content":" 脚本式Python式和Shell式 ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:5:2","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#脚本式"},{"categories":null,"content":" 基础语法","date":"2016-01-17","objectID":"/zh-cn/python-note1/:0:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#基础语法"},{"categories":null,"content":" 基本特点 大小写敏感 缩进（4个空格）而不是括号 注释：单行#，多行：‘‘‘或者\"\"\" input()和print() ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:1:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#基本特点"},{"categories":null,"content":" 数据类型","date":"2016-01-17","objectID":"/zh-cn/python-note1/:2:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#数据类型"},{"categories":null,"content":" 整数在整数除法中，除法（/）总是返回一个浮点数。，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符//，称为地板除 ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:2:1","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#整数"},{"categories":null,"content":" 浮点数","date":"2016-01-17","objectID":"/zh-cn/python-note1/:2:2","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#浮点数"},{"categories":null,"content":" 字符串 Python中的字符串不能改变。在Python3中，所有的字符串都是Unicode字符串 字符串是以单引号’或双引号\"括起来的任意文本，比如’abc’，“xyz”。多行字符串’‘‘或\"\"\") 默认不转义。转义：\\ 不转义/自然字符串：通过在字符串前加r或R 反斜杠()可以作为续行符，表示下一行是上一行的延续。也可以使用 “”\"…\"\"\" 或者 ‘’’…’’’ 跨越多行 字符串可以用+运算符连接在一起，用*运算符重复 Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始 str = 'Runoob' print (str) # 输出字符串 print (str[0:-1]) # 输出第一个到倒数第二个的所有字符 print (str[0]) # 输出字符串第一个字符 print (str[2:5]) # 输出从第三个开始到第五个的字符 print (str[2:]) # 输出从第三个开始的后的所有字符 print (str * 2) # 输出字符串两次 print (str + \"TEST\") # 连接字符串 ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:2:3","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#字符串"},{"categories":null,"content":" List List（列表）是 Python 中使用最频繁的数据类型 列表是写在方括号([])之间、用逗号分隔开的元素列表 list是一种有序的集合，列表中的元素是可以改变的 列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套） 支持append,pop,insert list = [ 'abcd', 786 , 2.23, 'runoob', 70.2 ] tinylist = [123, 'runoob'] print (list) # 输出完整列表 print (list[0]) # 输出列表第一个元素 print (list[1:3]) # 从第二个开始输出到第三个元素 print (list[2:]) # 输出从第三个元素开始的所有元素 print (tinylist * 2) # 输出两次列表 print (list + tinylist) # 连接列表 ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:2:4","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#list"},{"categories":null,"content":" Tuple 元组（tuple）与列表类似，不同之处在于元组的元素不能修改。 元组写在小括号(())里。可以把字符串看作一种特殊的元组 虽然tuple的元素不可改变(“指向不变”)，但它可以包含可变的对象 构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则： tup1 = () # 空元组 tup2 = (20,) # 一个元素，需要在元素后添加逗号 string、list和tuple都属于sequence（序列） ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:2:5","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#tuple"},{"categories":null,"content":" Set 集合（set）是一个无序不重复元素的序列。 基本功能是进行成员关系测试和删除重复元素。 可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 操作：add,remove 集合运算 student = {'Tom', 'Jim', 'Mary', 'Tom', 'Jack', 'Rose'} s = set([1, 2, 3]) ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:2:6","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#set"},{"categories":null,"content":" Dict 列表是有序的对象结合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取 字典是一种映射类型，字典用\"{ }“标识，它是一个无序的键(key) : 值(value)对集合。 键(key)必须使用不可变类型。 在同一个字典中，键(key)必须是唯一的。 dict是用空间来换取时间的一种方法 要避免key不存在的错误，有两种办法，一是通过in判断key是否存在： \u003e\u003e\u003e 'Thomas' in d False 二是通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value： \u003e\u003e\u003e d.get('Thomas') \u003e\u003e\u003e d.get('Thomas', -1) -1 ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:2:7","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#dict"},{"categories":null,"content":" 布尔值只有True和False两个值。可以参与and、or和not运算 ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:2:8","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#布尔值"},{"categories":null,"content":" 复数可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。如 1 + 2j、 1.1 + 2.2j ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:2:9","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#复数"},{"categories":null,"content":" 空值空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值 ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:2:10","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#空值"},{"categories":null,"content":" 类型判断type()不会认为子类是一种父类类型。 isinstance()会认为子类是一种父类类型。 ##变量 a, b, c = 1, 2, “runoob” ##常量 PI=3.14 ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:2:11","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#类型判断"},{"categories":null,"content":" 数值运算与运算符","date":"2016-01-17","objectID":"/zh-cn/python-note1/:3:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#数值运算与运算符"},{"categories":null,"content":" 算术运算符 2**5 # 乘方 17 % 3 # 取余 ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:3:1","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#算术运算符"},{"categories":null,"content":" 比较运算符!= ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:3:2","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#比较运算符"},{"categories":null,"content":" 赋值运算符","date":"2016-01-17","objectID":"/zh-cn/python-note1/:3:3","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#赋值运算符"},{"categories":null,"content":" 位运算符","date":"2016-01-17","objectID":"/zh-cn/python-note1/:3:4","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#位运算符"},{"categories":null,"content":" 逻辑运算符and or not ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:3:5","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#逻辑运算符"},{"categories":null,"content":" 成员运算符in, not in a = 10 b = 20 list = [1, 2, 3, 4, 5 ]; if ( a in list ): print (\"1 - 变量 a 在给定的列表中 list 中\") else: print (\"1 - 变量 a 不在给定的列表中 list 中\") ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:3:6","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#成员运算符"},{"categories":null,"content":" 身份运算符身份运算符用于比较两个对象的存储单元。类似于Java的==。 is:x is y, 类似 id(x) == id(y) is not,x is not y ，类似 id(a) != id(b) is 与 == 区别： is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。 ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:3:7","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#身份运算符"},{"categories":null,"content":" 控制结构","date":"2016-01-17","objectID":"/zh-cn/python-note1/:0:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#控制结构"},{"categories":null,"content":" 条件判断 age = 3 if age \u003e= 18: print('adult') elif age \u003e= 6: print('teenager') else: print('kid') ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:1:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#条件判断"},{"categories":null,"content":" 循环","date":"2016-01-17","objectID":"/zh-cn/python-note1/:2:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#循环"},{"categories":null,"content":" for in一种是for…in循环，经常用到range()函数。可以有else从句 names = ['Michael', 'Bob', 'Tracy'] for name in names: print(name) sum = 0 for x in range(101): sum = sum + x print(sum) ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:2:1","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#for-in"},{"categories":null,"content":" while第二种循环是while循环。可以有else从句 sum = 0 n = 99 while n \u003e 0: sum = sum + n n = n - 2 print(sum) ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:2:2","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#while"},{"categories":null,"content":" break","date":"2016-01-17","objectID":"/zh-cn/python-note1/:2:3","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#break"},{"categories":null,"content":" continue","date":"2016-01-17","objectID":"/zh-cn/python-note1/:2:4","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#continue"},{"categories":null,"content":" end 关键字关键字end可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符 ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:2:5","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#end-关键字"},{"categories":null,"content":" 迭代器 迭代是Python最强大的功能之一，是访问集合元素的一种方式 迭代器是一个可以记住遍历的位置的对象 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退 迭代器有两个基本的方法：iter() 和 next() ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:2:6","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#迭代器"},{"categories":null,"content":" 再议不可变对象对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的 ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:3:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#再议不可变对象"},{"categories":null,"content":" 参考资料","date":"2016-01-17","objectID":"/zh-cn/python-note1/:0:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#参考资料"},{"categories":null,"content":" Python 2.x vs 3.x2008年, Python3发布。最大的变化是源码文件默认使用utf-8编码 更多区别：Python3.x和Python2.x的区别 ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:1:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#python-2x-vs-3x"},{"categories":null,"content":" 学习材料 廖雪峰Python3教程 Runoob Python3教程 PHPXS Python基础教程 ","date":"2016-01-17","objectID":"/zh-cn/python-note1/:2:0","series":null,"tags":["开发","Python"],"title":"Python学习笔记1","uri":"/zh-cn/python-note1/#学习材料"},{"categories":null,"content":" 摘要最近几年，“个人品牌”、“个人影响力”逐渐被人提及。然而他们真的那么重要吗？我们又应该如何打造呢？ ","date":"2016-01-17","objectID":"/zh-cn/personal-brand/:0:0","series":null,"tags":["influence"],"title":"打造个人品牌","uri":"/zh-cn/personal-brand/#摘要"},{"categories":null,"content":" 正文首先是一篇泼冷水的文章，发人深省，引以为戒。 打造个人品牌的重要性被高估了 其中的摘要，清晰直白地表达了该文作者的观点： 关键在于先干出成绩，然后再打造个人品牌，否则就是本末倒置。然而，许多创业者把时间都花在面子工程上，结果盛名之下，其实难副。 不过，虽然如此，其他几篇文章中介绍的方法仍然有参考价值。罗列如下。 『1024』这个程序员节，聊聊程序员的自我进阶 听课总结：打造个人品牌的九个要点 如何提高影响力，为自己代言 打造你自己的程序员品牌 程序员如何打造个人品牌 程序员如何经营个人品牌 总结下来，有以下几点。 应该先干出一定成绩，然后再打造个人品牌，至少不应该急于求成 最好在各个网络平台用同一个ID标示自己。（这个有时候也比较难） 主要途径： 写博客（包括微博、传统博客、微信公众号等） 写书、做视频、办公开课 做网站、开发APP或者其他软件 发表论文、持有发明、专利 参与开源、参加各种技术交流和分享 参与创业 持续Impact ","date":"2016-01-17","objectID":"/zh-cn/personal-brand/:0:0","series":null,"tags":["influence"],"title":"打造个人品牌","uri":"/zh-cn/personal-brand/#正文"},{"categories":null,"content":" 什么是软件架构(Software Architecture)","date":"2016-01-17","objectID":"/zh-cn/my-view-on-architecture/:0:0","series":null,"tags":["architecture","OOD"],"title":"架构师之我见","uri":"/zh-cn/my-view-on-architecture/#什么是软件架构software-architecture"},{"categories":null,"content":" 定义 软件架构是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。（原文：(https://zh.wikipedia.org/wiki/软件架构)） ","date":"2016-01-17","objectID":"/zh-cn/my-view-on-architecture/:1:0","series":null,"tags":["architecture","OOD"],"title":"架构师之我见","uri":"/zh-cn/my-view-on-architecture/#定义"},{"categories":null,"content":" 起源1960年代，Dijkstra（别告诉我你不知道他是谁）等人就已提出这个概念。1990年代以来，由于Rational和Microsoft内部的相关活动，逐渐开始流行起来。 ","date":"2016-01-17","objectID":"/zh-cn/my-view-on-architecture/:2:0","series":null,"tags":["architecture","OOD"],"title":"架构师之我见","uri":"/zh-cn/my-view-on-architecture/#起源"},{"categories":null,"content":" 什么是架构师(Architect)","date":"2016-01-17","objectID":"/zh-cn/my-view-on-architecture/:0:0","series":null,"tags":["architecture","OOD"],"title":"架构师之我见","uri":"/zh-cn/my-view-on-architecture/#什么是架构师architect"},{"categories":null,"content":" 系统架构师(System Architect)其实，系统架构师分为很多种，企业架构师、软件架构师、硬件架构师、网络架构师、解决方案架构师等等。更多请参见：https://en.wikipedia.org/wiki/Software_architect. 当然本文的重点是关注软件架构师，尤其是互联网软件架构师 ","date":"2016-01-17","objectID":"/zh-cn/my-view-on-architecture/:1:0","series":null,"tags":["architecture","OOD"],"title":"架构师之我见","uri":"/zh-cn/my-view-on-architecture/#系统架构师system-architect"},{"categories":null,"content":" 软件架构师软件架构师当然就是负责设计上面所说的软件架构的人。（这不废话嘛。呵呵） ","date":"2016-01-17","objectID":"/zh-cn/my-view-on-architecture/:2:0","series":null,"tags":["architecture","OOD"],"title":"架构师之我见","uri":"/zh-cn/my-view-on-architecture/#软件架构师"},{"categories":null,"content":" 我对架构师的理解","date":"2016-01-17","objectID":"/zh-cn/my-view-on-architecture/:0:0","series":null,"tags":["architecture","OOD"],"title":"架构师之我见","uri":"/zh-cn/my-view-on-architecture/#我对架构师的理解"},{"categories":null,"content":" 工作职责 系统架构师，是技术的长期演进的远见，和主持系统各个部分的集成整合。职责是架构可否顺利实施、对核心部分质量的承担和框架搭建。 (原文：https://zh.wikipedia.org/wiki/系统架构师) ","date":"2016-01-17","objectID":"/zh-cn/my-view-on-architecture/:1:0","series":null,"tags":["architecture","OOD"],"title":"架构师之我见","uri":"/zh-cn/my-view-on-architecture/#工作职责"},{"categories":null,"content":" 任职要求0、架构师要有良好的沟通能力，跟技术团队、产品团队、业务团队等等都有良好的沟通 1、知识、技能方面 1）架构师必须是优秀的程序员，必须有足够的设计经验、编程经验（个人认为至少3年，“天才”可以例外） 2）架构师需要有广博的知识面，深刻理解各种原理。通晓软硬件、操作系统、网络等各种知识 2、思维方式、能力方面 1）抽象思维能力、逻辑推理能力、快速理解产品需求的能力 2）全局观、系统性思维 系统性思维、要理解整个系统的本质和关键点（重点、难点、容易变化的点、潜在的风险、最大的挑战和瓶颈） 3）要有技术前瞻性，要拥抱变化，但不要完美主义 不要企图一开始就设计一个完美的架构。优先考虑的应该是用较低的成本满足当前需求，并且保证一定的前瞻性就够了 3、演讲和分享 1）多在内部分享，帮助团队提升和成长 2）善于走出去，多分享交流，不断为团队注入新鲜血液，同时提升自己的水平和提高个人的影响力 ","date":"2016-01-17","objectID":"/zh-cn/my-view-on-architecture/:2:0","series":null,"tags":["architecture","OOD"],"title":"架构师之我见","uri":"/zh-cn/my-view-on-architecture/#任职要求"},{"categories":null,"content":" 首席架构师(CAO,Chief Architecture Officer)恩。等你先成为一名合格的架构师再说吧。CAO这个缩写也是醉了 ","date":"2016-01-17","objectID":"/zh-cn/my-view-on-architecture/:0:0","series":null,"tags":["architecture","OOD"],"title":"架构师之我见","uri":"/zh-cn/my-view-on-architecture/#首席架构师caochief-architecture-officer"},{"categories":null,"content":" 更多参考做人、做事，做架构师——架构师能力模型解析 软件架构师的工作 ","date":"2016-01-17","objectID":"/zh-cn/my-view-on-architecture/:1:0","series":null,"tags":["architecture","OOD"],"title":"架构师之我见","uri":"/zh-cn/my-view-on-architecture/#更多参考"},{"categories":null,"content":" 结语So, for me, at this moment, I got a long way to go. Fighting! ","date":"2016-01-17","objectID":"/zh-cn/my-view-on-architecture/:0:0","series":null,"tags":["architecture","OOD"],"title":"架构师之我见","uri":"/zh-cn/my-view-on-architecture/#结语"},{"categories":["branding"],"content":"现在github非常火，很多人（包括很多爱写作的非程序猿）都在上面开博了。推荐两篇文章： 为什么你要写博客？ 我为什么坚持写博客？ 工具方面，从基于Ruby的Jekyll，Octopress，到基于Python的Pelican，再到基于Node.js的Hexo。经过试用，我最终选择了Hexo。更多的工具，请看这里。 ","date":"2015-04-19","objectID":"/zh-cn/github-blogging-with-hexo/:0:0","series":null,"tags":["git","github","hexo"],"title":"Github Blogging with Hexo","uri":"/zh-cn/github-blogging-with-hexo/#"},{"categories":["branding"],"content":" Hexo 简介Hexo出自一个台湾大学生tommy351之手（原来我们大中华区也有世界级的编程牛人啊。赞一个！）。 Hexo是一个快速的、强大的Blog框架，主要是由 Node.js 构建出来的。同时支持多线程生成，上百个文件只需要花数秒中就能生成。 Hexo还支持GitHub Flavored Markdown 和所有的 Octopress 插件和 高兼容 Jekyll/Octopress。 ","date":"2015-04-19","objectID":"/zh-cn/github-blogging-with-hexo/:1:0","series":null,"tags":["git","github","hexo"],"title":"Github Blogging with Hexo","uri":"/zh-cn/github-blogging-with-hexo/#hexo-简介"},{"categories":["branding"],"content":" Hexo 安装Hexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。 安装Git和Node.js 安装和配置Hexo 申请github账号 编写和发布博客 具体可以参考这几篇文章： 如何搭建一个独立博客 Hexo 3.0 静态博客使用指南 hexo你的博客 hexo系列教程 ","date":"2015-04-19","objectID":"/zh-cn/github-blogging-with-hexo/:2:0","series":null,"tags":["git","github","hexo"],"title":"Github Blogging with Hexo","uri":"/zh-cn/github-blogging-with-hexo/#hexo-安装"},{"categories":["branding"],"content":" 问题及其解决","date":"2015-04-19","objectID":"/zh-cn/github-blogging-with-hexo/:3:0","series":null,"tags":["git","github","hexo"],"title":"Github Blogging with Hexo","uri":"/zh-cn/github-blogging-with-hexo/#问题及其解决"},{"categories":["branding"],"content":" npm install运行缓慢或失败可以指定国内的镜像网站，请参考这里 ","date":"2015-04-19","objectID":"/zh-cn/github-blogging-with-hexo/:3:1","series":null,"tags":["git","github","hexo"],"title":"Github Blogging with Hexo","uri":"/zh-cn/github-blogging-with-hexo/#npm-install运行缓慢或失败"},{"categories":["branding"],"content":" 中文的支持问题 在根目录的_config.yml中配置中文 language: zh-CN 保存文件的时候，要确保文件是UTF-8编码 ","date":"2015-04-19","objectID":"/zh-cn/github-blogging-with-hexo/:3:2","series":null,"tags":["git","github","hexo"],"title":"Github Blogging with Hexo","uri":"/zh-cn/github-blogging-with-hexo/#中文的支持问题"},{"categories":["branding"],"content":" 其他问题请参考：http://wp.huangshiyang.com/hexo常见问题解决方案 ","date":"2015-04-19","objectID":"/zh-cn/github-blogging-with-hexo/:3:3","series":null,"tags":["git","github","hexo"],"title":"Github Blogging with Hexo","uri":"/zh-cn/github-blogging-with-hexo/#其他问题"},{"categories":["branding"],"content":" Hexo常用命令 hexo n == hexo new hexo g == hexo generate hexo d == hexo deploy hexo s == hexo server 其他常用命令，请参考这里。 ","date":"2015-04-19","objectID":"/zh-cn/github-blogging-with-hexo/:4:0","series":null,"tags":["git","github","hexo"],"title":"Github Blogging with Hexo","uri":"/zh-cn/github-blogging-with-hexo/#hexo常用命令"},{"categories":["branding"],"content":" github域名绑定问题请参考前面的文章。 ","date":"2015-04-19","objectID":"/zh-cn/github-blogging-with-hexo/:5:0","series":null,"tags":["git","github","hexo"],"title":"Github Blogging with Hexo","uri":"/zh-cn/github-blogging-with-hexo/#github域名绑定问题"},{"categories":["branding"],"content":" Hexo的Theme（主题/皮肤）定制皮肤需要一定的Web前端基础（HTML/DIV/CSS/JavaScript）。更多主题，总有一款适合你。 ","date":"2015-04-19","objectID":"/zh-cn/github-blogging-with-hexo/:6:0","series":null,"tags":["git","github","hexo"],"title":"Github Blogging with Hexo","uri":"/zh-cn/github-blogging-with-hexo/#hexo的theme主题皮肤"},{"categories":["branding"],"content":" Markdown语法.md文件用纯文本软件编辑即可。这里有几个入门教程： Markdown 为什么我们要学习 Markdown 的三个理由 认识与入门 Markdown 献给写作者的 Markdown Markdown语法说明 ","date":"2015-04-19","objectID":"/zh-cn/github-blogging-with-hexo/:7:0","series":null,"tags":["git","github","hexo"],"title":"Github Blogging with Hexo","uri":"/zh-cn/github-blogging-with-hexo/#markdown语法"},{"categories":null,"content":" 自我介绍 软件工程师（7年Java开发经验） 摄影爱好者。兼职InfoQ社区编辑 从事行业：互联网/电子商务/软件 编程语言：Java/JavaScript。感兴趣：Python/Go 人类/自然语言：中文🇨🇳/英语🇬🇧。感兴趣：法语🇫🇷，德语🇩🇪，西班牙语🇪🇸等 技术方向：后端/服务器端开发。关注人工智能/AI 兴趣爱好：旅行、摄影（Sony A7R III）、电影、徒步、骑车(北京夜骑)等 不喜欢的：加班多的工作，刺多的鱼，重口味的菜（很辣，很臭，油腻，动物内脏等） ","date":"2015-04-19","objectID":"/zh-cn/about/:1:0","series":null,"tags":null,"title":"","uri":"/zh-cn/about/#自我介绍"},{"categories":null,"content":" 我的书单 完整的书单 ","date":"2015-04-19","objectID":"/zh-cn/about/:2:0","series":null,"tags":null,"title":"","uri":"/zh-cn/about/#我的书单"},{"categories":null,"content":" 我的翻译 Spring MVC实战 ","date":"2015-04-19","objectID":"/zh-cn/about/:3:0","series":null,"tags":null,"title":"","uri":"/zh-cn/about/#我的翻译"}]