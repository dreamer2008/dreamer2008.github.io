# 面向对象的设计原则



## 优秀的面向对象设计
众所周知，软件=程序+文档+数据。通常来说，在一个软件系统的生命周期中，软件维护的时间>>软件原始开发的时间。注：维护包括bug修复、各种优化和添加新功能。


所以，个人认为，优秀设计的终极目标是提高软件的可维护性(Maintainability)。不考虑可维护性的设计都是耍流氓。

除了这个终极目标之外，还有可复用性，可扩展性（甚至还有健壮性、灵活性，可插拔性等等），这些目标虽然含义不完全相同，但都是为了可维护性服务的。而所有这一切的基础，就是可读性。离开可读性，其他目标要么无法完成，要么代价特别大。它们的关系如下。

<img src="/images/tech/design_targets.png" width="600" height="400" />

**需要指出的是，文档的可读性也非常重要**。例如，有的API很多指标都不错，就是文档写得乱七八糟，导致使用非常不方便，这就得不偿失了。

## 面向对象的三大特性
**封装、继承、多态**是面向对象的三个基本特性。这是面向对象的语言为了提高可复用性和可维护性而具有的基本特性，也是OO语言相对于非OO语言的优势。

## 面向对象设计的基本原则

提到面向对象设计(OOD)，很多人会想到设计模式，但真正能把具体的设计模式信手拈来的又有多少呢？另一方面，其实这些设计模式只是具体的招数，不是内功。真正的内功心法更加重要，有了它们，你学习招数将更加顺手，即使不会具体的设计模式也能将软件设计得比较优雅，甚至你还可以在它们的指导下自创一些招数出来，做到“无招胜有招”。

### SOLID原则
[SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)最早是由俗称「Uncle Bob」的Robert C. Martin提出。他也是"Clean Code"这本书的作者。SOLID代表以下5大设计原则。

* Single Responsibility Principle(SRP,单一职责原则): 一个类应该有且只有一个去改变它的理由，这意味着一个类应该只有一个职责

* Open/Closed Principle(OCP,开闭原则): 对象或实体应该对扩展开放，对修改封闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类

* Liskov Substitution Principle(LSP,里氏替换原则): 任何基类可以出现的地方，子类一定可以出现。在对象 x 为类型 T 时 q(x) 成立，那么当 S 是 T 的子类时，对象 y 为类型 S 时 q(y) 也应成立。（即对父类的调用同样适用于子类）

* Interface Segregation Principle(ISP,接口隔离原则): 使用多个隔离/客户端相关的接口，比使用单个通用接口要好

* Dependency Inversion Principle(DIP,依赖反转原则): 实体必须依靠抽象而不是具体实现。它表示高层次的模块不应该依赖于低层次的模块，它们都应该依赖于抽象

### 其他常用原则
除了SOLID原则，还有一些其他原则会经常被提到。

* Composite Reuse Principle(CRP,合成复用原则):尽量使用合成/聚合的方式，而不是使用继承

* 迪米特法则(Law of Demeter)
又叫最少知道原则(Least Knowledge Principle)。一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立

* 避免重复原则（DRY - Don’t Repeat Yourself）

又叫一次且仅一次（once and only once，简称OAOO)。编程的最基本原则是避免重复。在程序代码中总会有很多结构体，如循环、函数、类等等。一旦你重复某个语句或概念，就会很容易形成一个抽象体

* 简单原则（Keep It Simple and Stupid）

简单是软件设计的目标，简单的代码占用时间少，漏洞少，并且易于修改

* 避免过早优化(Avoid Premature Optimization)

除非你的代码运行的比你想像中的要慢，否则别去优化。假如你真的想优化，就必须先想好如何用数据证明，它的速度变快了。
“过早的优化是一切罪恶的根源”——Donald Knuth
